// Brandon Doyle
// January 2026
// MKS_serialRead v0.0.1
// Controller Software for MKS 925 MicroPirani Pressure Transducer
//
// Description:
// It just reads via Serial and displays to OLED. No funnybusiness.
// I may add some funnybusiness later though, who knows?
//
// Devices and connections:
// - MKS 925 via hardware serial
// - OLED screen (128x32) via I2C

const char softwareVersion[] = "v0.0.1";

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

/////////////Begin OLED stuff///////////////
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library. 
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
// On an arduino LEONARDO:   2(SDA),  3(SCL), ...
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
#define LOGO_HEIGHT   32
#define LOGO_WIDTH    83
const unsigned char logo_bmp[] PROGMEM = {
	// 'N7, 83x32px
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xf8, 0x07, 0xff, 0xfe, 
	0x03, 0x00, 0x00, 0x00, 0x07, 0xc1, 0xe0, 0xf8, 0x01, 0xff, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x03, 
	0xc1, 0xe0, 0xf8, 0x00, 0xff, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe0, 0xf8, 0x00, 0x7f, 
	0xfe, 0x03, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe0, 0xf8, 0x00, 0x3f, 0xfe, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0xc1, 0xe0, 0xf8, 0x00, 0x1f, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x03, 0xc1, 0xe0, 0xf8, 0x00, 
	0x0f, 0xfe, 0x03, 0xff, 0xff, 0xf0, 0x07, 0xc1, 0xe0, 0xf8, 0x18, 0x07, 0xfe, 0x03, 0xff, 0xff, 
	0xe0, 0x0f, 0x81, 0xe0, 0xf8, 0x18, 0x03, 0xfe, 0x03, 0xff, 0xff, 0xc0, 0x1f, 0x01, 0xe0, 0xf8, 
	0x1c, 0x01, 0xfe, 0x03, 0xff, 0xff, 0x00, 0x3e, 0x01, 0xe0, 0xf8, 0x1e, 0x01, 0xfe, 0x03, 0xff, 
	0xfe, 0x00, 0x7c, 0x01, 0xe0, 0xf8, 0x1f, 0x00, 0xfe, 0x03, 0xff, 0xfc, 0x00, 0xf8, 0x01, 0xe0, 
	0xf8, 0x1f, 0x80, 0x7e, 0x03, 0xff, 0xf8, 0x01, 0xf0, 0x01, 0xe0, 0xf8, 0x1f, 0xc0, 0x3e, 0x03, 
	0xff, 0xf0, 0x03, 0xe0, 0x01, 0xe0, 0xf8, 0x1f, 0xc0, 0x1e, 0x03, 0xff, 0xe0, 0x07, 0xc0, 0x01, 
	0xe0, 0xf8, 0x1f, 0xe0, 0x0e, 0x03, 0xff, 0xc0, 0x0f, 0x80, 0x01, 0xe0, 0xf8, 0x1f, 0xf0, 0x06, 
	0x03, 0xff, 0x80, 0x1f, 0x00, 0x01, 0xe0, 0xf8, 0x1f, 0xf8, 0x00, 0x03, 0xff, 0x00, 0x3e, 0x00, 
	0x01, 0xe0, 0xf8, 0x1f, 0xfc, 0x00, 0x03, 0xfe, 0x00, 0x7c, 0x00, 0x01, 0xe0, 0xf8, 0x1f, 0xfe, 
	0x00, 0x03, 0xfc, 0x00, 0xf8, 0x00, 0x01, 0xe0, 0xf8, 0x1f, 0xff, 0x00, 0x03, 0xf8, 0x01, 0xf0, 
	0x00, 0x01, 0xe0, 0xf8, 0x1f, 0xff, 0x00, 0x03, 0xf0, 0x03, 0xe0, 0x00, 0x01, 0xe0, 0xf8, 0x1f, 
	0xff, 0xc0, 0x03, 0xe0, 0x07, 0xc0, 0x00, 0x01, 0xe0, 0xf8, 0x1f, 0xff, 0xf0, 0x03, 0xc0, 0x0f, 
	0x80, 0x00, 0x01, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0
};

char* msg = new char[50];
void OLED_show(char* msg){
  display.clearDisplay();

  display.setTextSize(2);             // Double the normal 1:1 pixel scale
  display.setTextColor(SSD1306_WHITE);// Draw white text (monochrome board, but doesn't work without this)
  display.setCursor(0,16);            // In pixels (x,y) from top left corner

  display.print(msg);
  display.display();
}
/////////////End OLED stuff///////////////

/////////////Begin pressure reading stuff///////////////
float press = 0.0;
int timeout = 10;

//For now, getP() doesn't even interpret the value, because we're
//not processing or saving it, it just puts the characters on
//the screen.
void getP(){
	Serial.println(F("@254PR1?;FF"));
	for(int i=0;i<timeout;i++){
		delay(100);
		if (Serial.available() > 0){
			Serial.readBytes(msg,17);
			for(int j=0;j<50;j++){
				if(msg[j]==';'){
					msg[j]='\0';
				}
			}
			OLED_show(msg+7);
			return;
		}

	}
	OLED_show("Error");
	return;
}
/////////////End pressure reading stuff///////////////

void setup() {
  Wire.begin();
  Serial.begin(9600);

  //SPI requires begin() and THEN beginTransaction()
  SPI.begin();
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE1));

  //Begin I2C communication to the OLED screen:
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  
  // Show splash screen:
  //display.display();
  display.clearDisplay();

  display.drawBitmap(
    (display.width()  - LOGO_WIDTH ) / 2,
    (display.height() - LOGO_HEIGHT) / 2,
    logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1);
  display.display();

  delay(1000); // Pause for 1 second
  // Clear the OLED buffer
  display.clearDisplay();
}

void loop() {
  // put your main code here, to run repeatedly:
	getP();
  delay(50);

}
